const _ = require('lodash');
const {Path} = require('path-parser');
//'url' help us to parse the url
const {URL} = require('url');

const mongoose = require('mongoose');
const requireLogin = require('../middlewares/requireLogin');
const requireCredits = require('../middlewares/requireCredits');
const surveyTemplate = require('../services/emailTemplates/surveyTemplate');
const Mailer = require('../services/Mailer');
const Survey = mongoose.model('surveys');
module.exports = app => {
  // the way to deal with the wild card (:choice)
  app.get('/api/surveys/:surveyId/:choice', (req, res) => {
    res.send('Thanks for voting');
  });

  app.post( '/api/surveys/webhooks', ( req, res) => {
    const p = new Path('/api/surveys/:surveyId/:choice');
    // const events = _.map(req.body, event => {
    //   // extract the path from the url
    //   const pathname = new URL( event.url).pathname ;
    //   // if the url does not have either surveyId or choice, the test result will be null
    //   const match = p.test(pathname);
    //   if( match ){
    //     return {
    //       email : event.email,
    //       surveyId : match.surveyId,
    //       choice: match.choice
    //     }
    //   }
    // });
    // // compact function go through all the elements of the array and removes
    // // any elements that are undefined
    // const compactEvents = _.compact(event);
    // // make sure we do not have duplicate records in the array
    // // cannot have multiple votes on the same email on the same survey
    // const uniqueEvents = _.uniqBy(compactEvents, 'email', 'surveyId');

     _.chain(req.body)
     .map( event => {
      // extract the path from the url
      const pathname = new URL( event.url).pathname ;
      // if the url does not have either surveyId or choice, the test result will be null
      const match = p.test(pathname);
      if( match ){
        return {
          email : event.email,
          surveyId : match.surveyId,
          choice: match.choice
        };
      }
    })
    // compact function go through all the elements of the array and removes
    // any elements that are undefined
    .compact()
    // make sure we do not have duplicate records in the array
    // cannot have multiple votes on the same email on the same survey
    .uniqBy('email', 'surveyId')
    .each( ({surveyId, email, choice }) => {

      // find a survey that satisfy all the search criteria, and
      // update the object that has been found
      // moogo: _id
      Survey.updateOne({
        _id : surveyId,
        recipients: {
          $elemMatch : { email: email, responded: false }
        },
      }, {
        //[choice] : key interpellation
        // inc, set moogo operators
        $inc : { [choice] : 1 },
        // $ represents the matched recipient found in the original query
        $set: { 'recipients.$.responded' : true  },
        lastResponded : Date.now()

      }).exec();
    })
    .value();

    res.send({});
  });
  // a post request
  // 2 prerequisites the user is logged in // has enough creadit
  // add middlewares in the order that we want them to be executed
  app.post('/api/surveys',requireLogin, requireCredits, async (req, res) => {
    // the usage of body-parsing
    const {title, subject, body, recipients} = req.body;
    // take the properties from the request body and make new instance of survey
    const survey = new Survey({
      title, subject, body,
      recipients: recipients.split(",").map(email => ({email : email.trim()})),
      // the id property is automatically generated by mongoose in mongo
      _user: req.user.id,
      dateSent: Date.now(),
    });
    //send off an email
    // the survey preserve all the data for a mailer
    // template will be a function that produce a html out of the body of the survey
    // and this html will be the body of the mailer
    const mailer = new Mailer(survey, surveyTemplate(survey));
    try{
      await mailer.send();
      /// manully persist this instance to the mongo database
      await survey.save();
      //save the status of the user
      req.user.credits -= 1;
      const user = await req.user.save();
      //send back the new user so that the header could automativally
      //update
      res.send(user);
    } catch (err){
      res.status(422).send(err);
  }
  });
};
